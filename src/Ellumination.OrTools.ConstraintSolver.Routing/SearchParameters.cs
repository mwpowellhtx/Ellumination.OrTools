using System;

namespace Ellumination.OrTools.ConstraintSolver.Routing
{
    using Google.Protobuf.WellKnownTypes;
    using LocalSearchNeighborhoodOperators = Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators;
    using OrConstraintSolver = Google.OrTools.ConstraintSolver.operations_research_constraint_solver;
    using RoutingSearchParameters = Google.OrTools.ConstraintSolver.RoutingSearchParameters;
    using static LocalSearchMetaheuristic;

    //// TODO: TBD: will circle around and clean up the notes but for now it is reference while we sort these issues out...
    // ? https://github.com/protocolbuffers/protobuf/blob/d16bf914bc5ba569d2b70376051d15f68ce4322d/csharp/CHANGES.txt
    // C#: do not use <PublicSign>true</PublicSign> on non-windows
    // i.e. https://github.com/protocolbuffers/protobuf/commit/930ab0f33d86a4c01995a729ba197c4683db8a97
    // https://github.com/protocolbuffers/protobuf
    // https://github.com/protocolbuffers/protobuf/issues
    // ? [csharp] Allow for unsealed message output to be generated / https://github.com/protocolbuffers/protobuf/issues/8169
    // Allow for Duration deconstruction into constituent member components / https://github.com/protocolbuffers/protobuf/issues/8168
    // https://github.com/google/or-tools/branches
    // C#: Added Duration deconstruction capability. #8173 / https://github.com/protocolbuffers/protobuf/pull/8173
    // https://github.com/mwpowellhtx/protobuf/tree/feature/duration-deconstruction
    // TODO: TBD: would CG work in this instance?
    // TODO: TBD: I also want to avoid too many in the way of 3P dependencies, i.e. Automapper...
    // TODO: TBD: or esoteric usage of things like dynamic, interfaces, etc...
    /// <summary>
    /// Offers an opportunity to adapt Search parameters into the wrapper framework.
    /// </summary>
    /// <see cref="!:https://github.com/google/or-tools/issues/2301">[dotnet::routing]
    /// Unseal the sealed parameters</see>
    /// <see cref="!:https://github.com/protocolbuffers/protobuf/issues/8169">[csharp]
    /// Allow for unsealed message output to be generated</see>
    public class SearchParameters : Parameters
    {
        /// <summary>
        /// Gets or Sets the LocalSearchOperators.
        /// </summary>
        public virtual LocalSearchNeighborhoodOperators LocalSearchOperators { get; set; }

        /// <summary>
        /// Number of expensive arcs to consider cutting in the
        /// <see cref="LocalSearchNeighborhoodOperators.UseRelocateExpensiveChain"/>
        /// neighborhood operator. This must be greater than <c>2</c>. User note, the
        /// number of neighbors generated by the operator for
        /// <c>relocate_expensive_chain_num_arcs_to_consider = K</c> is
        /// <c>~(K * (K - 1) / 2 * number_of_routes * number_of_nodes)</c>.
        /// </summary>
        public virtual int RelocateExpensiveChainNumArcsToConsider { get; set; }

        /// <summary>
        /// Number of expensive arcs to consider cutting in the
        /// <em>FilteredHeuristicExpensiveChainLNSOperator</em> operator.
        /// </summary>
        public virtual int HeuristicExpensiveChainLnsNumArcsToConsider { get; set; }

        /// <summary>
        /// Local search metaheuristics used to guide the search.
        /// </summary>
        public virtual LocalSearchMetaheuristicBridge LocalSearchMetaheuristic { get; set; } = default(LocalSearchMetaheuristic);

        private double _guidedLocalSearchLambdaCoefficient;

        /// <summary>
        /// These are advanced settings which should not be modified unless you know what you
        /// ar doing. Lambda coefficient used to penalize arc costs when
        /// <see cref="GuidedLocalSearch"/> is used. Must be positive.
        /// </summary>
        public virtual double GuidedLocalSearchLambdaCoefficient
        {
            get => this._guidedLocalSearchLambdaCoefficient;
            set => this._guidedLocalSearchLambdaCoefficient = Math.Max(default, value);
        }

        /// <summary>
        /// Search control. If <c>true</c>, the solver should use depth-first search rather
        /// than local search to solve the problem.
        /// </summary>
        public virtual bool UseDepthFirstSearch { get; set; }

        /// <summary>
        /// Limit to the time spent in the search.
        /// </summary>
        public virtual DurationBridge TimeLimit { get; set; } = DurationBridge.Null;

        /// <summary>
        /// If <c>true</c>, use the CP-SAT solver to find a solution. If <see cref="UseCp"/>
        /// is also <c>true</c>, the CP-SAT solver will be run after the CP solver if there is
        /// time remaining and will use the CP solution as a hint for the CP-SAT search. As of
        /// May 2019, only TSP models can be solved.
        /// </summary>
        public virtual OptionalBooleanBridge UseCpSat { get; set; } = OptionalBooleanBridge.Null;

        // TODO: TBD: define an internal one...
        // TODO: TBD: potentially we look to code generate some things here?
        /// <summary>
        /// Gets or Sets the ContinuousSchedulingSolver.
        /// </summary>
        public virtual SchedulingSolverBridge ContinuousSchedulingSolver { get; set; } = default(SchedulingSolver);

        /// <summary>
        /// Gets or Sets the MixedIntegerSchedulingSolver.
        /// </summary>
        public virtual SchedulingSolverBridge MixedIntegerSchedulingSolver { get; set; } = default(SchedulingSolver);

        /// <summary>
        /// Minimum step by which the solution must be improved in local search. <c>0</c> means
        /// <em>unspecified</em>. If this value is <em>fractional</em>, it will get rounded to the
        /// nearest integer.
        /// </summary>
        public virtual double OptimizationStep { get; set; }

        /// <summary>
        /// Number of solutions to collect during the search. Corresponds to the best
        /// solutions found during the search. <c>0</c> means <em>unspecified</em>.
        /// </summary>
        public virtual int NumberOfSolutionsToCollect { get; set; }

        /// <summary>
        /// Search limits. Limit to the number of solutions generated during the search.
        /// <c>0</c> means <em>unspecified</em>.
        /// </summary>
        public virtual long SolutionLimit { get; set; }

        /// <summary>
        /// Limit to the time spent in the completion search for each local search neighbor.
        /// </summary>
        public virtual DurationBridge LnsTimeLimit { get; set; } = DurationBridge.Null;

        /// <summary>
        /// If true use minimum matching instead of minimal matching in the <em>Christofides</em>
        /// algorithm.
        /// </summary>
        public virtual bool ChristofidesUseMinimumMatching { get; set; }

        /// <summary>
        /// If <c>true</c>, use the CP solver to find a solution. Either local or depth-first
        /// search will be used depending on the value of
        /// <see cref="RoutingSearchParameters.UseDepthFirstSearch"/>. Will be run before the
        /// CP-SAT solver, <see cref="UseCpSat"/>.
        /// </summary>
        /// <see cref="UseCpSat"/>
        public virtual OptionalBooleanBridge UseCp { get; set; } = OptionalBooleanBridge.Null;

        /// <summary>
        /// Neighbors ratio for the heuristic when used in a local search operator.
        /// </summary>
        /// <see cref="!:https://github.com/google/or-tools/blob/master/ortools/constraint_solver/routing_parameters.proto#L328"/>
        public virtual double CheapestInsertionLsOperatorNeighborsRatio { get; set; }

        /// <summary>
        /// Miscellaneous. Some of these are advanced settings which should not be modified
        /// unless you know what you are doing. Activates search logging. For each solution
        /// found during the search, the following will be displayed: its objective value,
        /// the maximum objective value since the beginning of the search, the elapsed time
        /// since the beginning of the search, the number of branches explored in the search
        /// tree, the number of failures in the search tree, the depth of the search tree, the
        /// number of local search neighbors explored, the number of local search neighbors
        /// filtered by local search filters, the number of local search neighbors accepted,
        /// the total memory used and the percentage of the search done.
        /// </summary>
        public virtual bool LogSearch { get; set; }

        /// <summary>
        /// Ratio, between 0 and 1, of available vehicles in the model on which farthest nodes
        /// of the model are inserted as seeds in the GlobalCheapestInsertion first solution
        /// heuristic.
        /// </summary>
        public virtual double CheapestInsertionFarthestSeedsRatio { get; set; }

        /// <summary>
        /// When <c>true</c>, the routes are built in parallel, sequentially otherwise.
        /// </summary>
        public virtual bool SavingsParallelRoutes { get; set; }

        /// <summary>
        /// Coefficient of the cost of the arc for which the saving value is being computed:
        /// <c>Saving(a-->b) = Cost(a-->end) + Cost(start-->b) - savings_arc_coefficient
        /// * Cost(a-->b)</c>. This parameter must be greater than <c>0</c>, and its default
        /// value is <c>1</c>.
        /// </summary>
        public virtual double SavingsArcCoefficient { get; set; }

        /// <summary>
        /// Add savings related to reverse arcs when finding the nearest neighbors of the nodes.
        /// </summary>
        public virtual bool SavingsAddReverseArcs { get; set; }

        /// <summary>
        /// The number of neighbors considered for each node in the Savings heuristic
        /// is chosen so that the space used to store the savings does not exceed
        /// <c>savings_max_memory_usage_bytes</c>, which must be in <c>[0, 1e10]</c>.
        /// Note, if both <c>savings_neighbors_ratio</c> and
        /// <c>savings_max_memory_usage_bytes</c> are specified, the number of neighbors
        /// considered for each node will be the minimum of the two numbers determined
        /// by these parameters.
        /// </summary>
        public virtual double SavingsMaxMemoryUsageBytes { get; set; }

        /// <summary>
        /// Parameters specific to the Savings first solution heuristic. Ratio, in <c>[0, 1]</c>,
        /// of neighbors to consider for each node when constructing the savings. If unspecified,
        /// its value is considered to be <c>1.0</c>.
        /// </summary>
        public virtual double SavingsNeighborsRatio { get; set; }

        /// <summary>
        /// Advanced first solutions strategy settings. <b>Do not touch these unless you know
        /// what you are doing</b>. Use filtered version of first solution strategy if available.
        /// </summary>
        public virtual bool UseUnfilteredFirstSolutionStrategy { get; set; }

        /// <summary>
        /// First solution strategies, used as starting point of local search.
        /// </summary>
        public virtual FirstSolutionStrategyBridge FirstSolutionStrategy { get; set; } = default(FirstSolutionStrategy);

        /// <summary>
        /// Ratio, in <c>[0, 1]</c>, of neighbors to consider for each node when creating new
        /// insertions in the parallel or sequential cheapest insertion heuristic. If not
        /// overridden, its default value is <c>1</c>, meaning all neighbors will be considered.
        /// Neighbors ratio for the first solution heuristic.
        /// </summary>
        public virtual double CheapestInsertionFirstSolutionNeighborsRatio { get; set; }

        /// <summary>
        /// In logs, cost values will be scaled and offset by the given values in the following
        /// way: <c>log_cost_scaling_factor * (cost + log_cost_offset)</c>.
        /// </summary>
        public virtual double LogCostScalingFactor { get; set; }

        /// <summary>
        /// Gets or Sets the LogCostOffset.
        /// </summary>
        public virtual double LogCostOffset { get; set; }

        /// <summary>
        /// Propagation control. These are advanced settings which should not be modified unless
        /// you know what you are doing. Use constraints with full propagation in routing model,
        /// instead of <em>light propagation only</em>. Full propagation is only necessary when
        /// using depth-first search or for models which require strong propagation to finalize
        /// the value of secondary variables. Changing this setting to true will slow down the
        /// search in most cases and increase memory consumption in all cases.
        /// </summary>
        public virtual bool UseFullPropagation { get; set; }

        /// <summary>
        /// Constructs an instance of the <see cref="SearchParameters"/>.
        /// </summary>
        internal SearchParameters()
        {
        }

        /// <summary>
        /// Constructs an instance of the <see cref="SearchParameters"/>.
        /// </summary>
        /// <param name="source"></param>
        private SearchParameters(RoutingSearchParameters source)
            : base(source) =>
            CopyFrom(this, source);

        /// <summary>
        /// Copies <paramref name="target"/> bits From <paramref name="source"/>.
        /// </summary>
        /// <param name="target"></param>
        /// <param name="source"></param>
        /// <returns></returns>
        private static SearchParameters CopyFrom(SearchParameters target, RoutingSearchParameters source)
        {
            /* We keep the initialization separate, why? Because if there are any errors
             * during assignment, we want to isolate precisely where those might be. */

            target.LocalSearchOperators = source.LocalSearchOperators;
            target.RelocateExpensiveChainNumArcsToConsider = source.RelocateExpensiveChainNumArcsToConsider;
            target.HeuristicExpensiveChainLnsNumArcsToConsider = source.HeuristicExpensiveChainLnsNumArcsToConsider;
            target.LocalSearchMetaheuristic = source.LocalSearchMetaheuristic;
            target.GuidedLocalSearchLambdaCoefficient = source.GuidedLocalSearchLambdaCoefficient;
            target.UseDepthFirstSearch = source.UseDepthFirstSearch;
            target.TimeLimit = source.TimeLimit;
            target.UseCpSat = source.UseCpSat;
            target.ContinuousSchedulingSolver = source.ContinuousSchedulingSolver;
            target.MixedIntegerSchedulingSolver = source.MixedIntegerSchedulingSolver;
            target.OptimizationStep = source.OptimizationStep;
            target.NumberOfSolutionsToCollect = source.NumberOfSolutionsToCollect;
            target.SolutionLimit = source.SolutionLimit;
            target.LnsTimeLimit = source.LnsTimeLimit;
            target.ChristofidesUseMinimumMatching = source.ChristofidesUseMinimumMatching;
            target.UseCp = source.UseCp;
            target.CheapestInsertionLsOperatorNeighborsRatio = source.CheapestInsertionLsOperatorNeighborsRatio;
            target.LogSearch = source.LogSearch;
            target.CheapestInsertionFarthestSeedsRatio = source.CheapestInsertionFarthestSeedsRatio;
            target.SavingsParallelRoutes = source.SavingsParallelRoutes;
            target.SavingsArcCoefficient = source.SavingsArcCoefficient;
            target.SavingsAddReverseArcs = source.SavingsAddReverseArcs;
            target.SavingsMaxMemoryUsageBytes = source.SavingsMaxMemoryUsageBytes;
            target.SavingsNeighborsRatio = source.SavingsNeighborsRatio;
            target.UseUnfilteredFirstSolutionStrategy = source.UseUnfilteredFirstSolutionStrategy;
            target.FirstSolutionStrategy = source.FirstSolutionStrategy;
            target.CheapestInsertionFirstSolutionNeighborsRatio = source.CheapestInsertionFirstSolutionNeighborsRatio;
            target.LogCostScalingFactor = source.LogCostScalingFactor;
            target.LogCostOffset = source.LogCostOffset;
            target.UseFullPropagation = source.UseFullPropagation;

            return target;
        }

        /// <summary>
        /// Copies <paramref name="source"/> bits To <paramref name="target"/>.
        /// </summary>
        /// <param name="source"></param>
        /// <param name="target"></param>
        /// <returns></returns>
        private static RoutingSearchParameters CopyTo(SearchParameters source, RoutingSearchParameters target)
        {
            target.LocalSearchOperators = source.LocalSearchOperators;
            target.RelocateExpensiveChainNumArcsToConsider = source.RelocateExpensiveChainNumArcsToConsider;
            target.HeuristicExpensiveChainLnsNumArcsToConsider = source.HeuristicExpensiveChainLnsNumArcsToConsider;
            target.LocalSearchMetaheuristic = source.LocalSearchMetaheuristic;
            target.GuidedLocalSearchLambdaCoefficient = source.GuidedLocalSearchLambdaCoefficient;
            target.UseDepthFirstSearch = source.UseDepthFirstSearch;
            target.TimeLimit = source.TimeLimit;
            target.UseCpSat = source.UseCpSat;
            target.ContinuousSchedulingSolver = source.ContinuousSchedulingSolver;
            target.MixedIntegerSchedulingSolver = source.MixedIntegerSchedulingSolver;
            target.OptimizationStep = source.OptimizationStep;
            target.NumberOfSolutionsToCollect = source.NumberOfSolutionsToCollect;
            target.SolutionLimit = source.SolutionLimit;
            target.LnsTimeLimit = source.LnsTimeLimit;
            target.ChristofidesUseMinimumMatching = source.ChristofidesUseMinimumMatching;
            target.UseCp = source.UseCp;
            target.CheapestInsertionLsOperatorNeighborsRatio = source.CheapestInsertionLsOperatorNeighborsRatio;
            target.LogSearch = source.LogSearch;
            target.CheapestInsertionFarthestSeedsRatio = source.CheapestInsertionFarthestSeedsRatio;
            target.SavingsParallelRoutes = source.SavingsParallelRoutes;
            target.SavingsArcCoefficient = source.SavingsArcCoefficient;
            target.SavingsAddReverseArcs = source.SavingsAddReverseArcs;
            target.SavingsMaxMemoryUsageBytes = source.SavingsMaxMemoryUsageBytes;
            target.SavingsNeighborsRatio = source.SavingsNeighborsRatio;
            target.UseUnfilteredFirstSolutionStrategy = source.UseUnfilteredFirstSolutionStrategy;
            target.FirstSolutionStrategy = source.FirstSolutionStrategy;
            target.CheapestInsertionFirstSolutionNeighborsRatio = source.CheapestInsertionFirstSolutionNeighborsRatio;
            target.LogCostScalingFactor = source.LogCostScalingFactor;
            target.LogCostOffset = source.LogCostOffset;
            target.UseFullPropagation = source.UseFullPropagation;

            return target;
        }

        /// <summary>
        /// Implicitly converts the <paramref name="source"/> <see cref="SearchParameters"/>
        /// to an <see cref="RoutingSearchParameters"/> instance.
        /// </summary>
        /// <param name="source"></param>
        /// <returns>The implicitly converted <see cref="RoutingSearchParameters"/> instance.</returns>
        public static implicit operator RoutingSearchParameters(SearchParameters source) => source == null
            ? null
            : CopyTo(source, OrConstraintSolver.DefaultRoutingSearchParameters());

        /// <summary>
        /// Implicitly converts the <paramref name="source"/>
        /// <see cref="RoutingSearchParameters"/> to an instance of
        /// <see cref="SearchParameters"/>.
        /// </summary>
        /// <param name="source"></param>
        /// <returns>The implicitly converted <see cref="SearchParameters"/> instance.</returns>
        public static implicit operator SearchParameters(RoutingSearchParameters source) => source == null
            ? null
            : new SearchParameters(source);
    }
}
